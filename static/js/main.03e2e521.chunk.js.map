{"version":3,"sources":["TextAnalysis.js","components/AnalysisForm.js","components/AnalysisSidebar.js","AnalysisContainer.js","App.js","index.js"],"names":["TextAnalysis","getCharCount","text","length","err","console","log","getWordCount","split","getSentenceCount","getParagraphCount","getBigramCount","bigramCount","bigramArr","map","sentence","forEach","i","sentimentAnalysis","a","uri","fetch","headers","Authorization","then","res","json","sentimentData","undefined","traits","value","confidence","toFixed","catch","AnalysisForm","setText","id","htmlFor","onInput","e","target","cols","rows","AnalysisSidebar","analytics","className","data-tip","data-for","data-place","charCount","sentenceCount","paragraphCount","html","AnalysisContainer","App","useState","wordCount","setAnalytics","useEffect","prevState","sentiment","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.03e2e521.chunk.js","sourcesContent":["const getCharCount = function(text) { //gets character count from text, including spaces\n  try {\n    return text.length;\n  } catch(err) {\n    console.log('ERR in TextAnalysis.getCharCount: ', err);\n  }\n}\n\nconst getWordCount = function(text) { //gets word count from text\n  try {\n    return text.split(' ').length; //split by spaces in text and get length of array\n  } catch(err) {\n    console.log('ERR in TextAnalysis.getWordCount: ', err);\n  }\n}\n\nconst getSentenceCount = function(text) { //gets sentence count from text\n  try {\n    return text.split(/[.!?]+\\s/).length; //split by terminating punctuation and whitespace\n  } catch(err) {\n    console.log('ERR in TextAnalysis.getSentenceCount: ', err);\n  }\n}\n\nconst getParagraphCount = function(text) { //gets paragraph count from text\n  try {\n    //splits text based on 2 newlines\n    return text.split(/\\n *\\n/g).length; \n  } catch(err) {\n    console.log('ERR in TextAnalysis.getParagraphCount: ', err);\n  }\n}\n\nconst getBigramCount = function(text) { //gets bigram count from text\n  try {\n    //initialize counter\n  let bigramCount = 0;\n  //split the text into individual arrays for each sentence\n  let bigramArr = text.split(/[.!?]+\\s/);\n  //split each sentence array into arrays of words\n  bigramArr = bigramArr.map(sentence =>  sentence.split(' '));\n  //iterate through every subarray to find non-matching pairs\n  bigramArr.forEach(sentence => {\n    for (let i = 0; i < sentence.length - 1; i++) { \n      if (sentence[i] !== sentence[i + 1]) bigramCount += 1;\n    }\n  })\n  return bigramCount;\n  } catch(err) {\n    console.log('ERR in TextAnalysis.getBigramCount: ', err);\n  }\n}\n\nconst sentimentAnalysis = async (text) => { //calls wit.ai for sentiment analysis\n  try {\n    const uri = 'https://api.wit.ai/message?v=20200513&q=' + text; \n    const auth = 'Bearer ' + process.env.REACT_APP_CLIENT_TOKEN;\n  \n    return await fetch(uri, { headers: { Authorization: auth }})\n      .then((res) => res.json())\n      .then((sentimentData) => {\n        console.log('sentimentData', sentimentData);\n        if (sentimentData.traits['wit$sentiment'] !== undefined) {\n          return `${sentimentData.traits['wit$sentiment'][0].value} (${((sentimentData.traits['wit$sentiment'][0].confidence * 100).toFixed(2))}% confidence)`;\n        } else {\n          return 'Unable to determine sentiment at this time.';\n        }\n      })\n      .catch((err) => console.log('ERR in POST request to wit.ai: ', err));\n  } catch(err) {\n    console.log('ERR in TextAnalysis.sentimentAnalysis: ', err)\n  }\n}\n\nconst TextAnalysis = { \n  getCharCount,\n  getWordCount,\n  getSentenceCount,\n  getParagraphCount,\n  getBigramCount,\n  sentimentAnalysis\n};\n\nexport default TextAnalysis;","import '../css/AnalysisForm.css';\n\nexport default function AnalysisForm({ text, setText }) {\n  return (\n    <div id=\"analysis-form\">\n     <label id=\"text-analysis-label\" htmlFor=\"text-analysis-textarea\">Analyze your text!</label>\n     <textarea \n        id=\"text-analysis-textarea\" \n        value={text}\n        onInput={e => setText(e.target.value)}\n        cols=\"50\"\n        rows=\"10\"\n      />\n    </div>\n  )\n}","import '../css/AnalysisSidebar.css';\nimport ReactTooltip from \"react-tooltip\";\n\nexport default function AnalysisSidebar({ analytics }) {\n\n  return (\n    <div id=\"analysis-sidebar\">\n      <div \n        className=\"analysis-item\"\n        data-tip=\"Counts all characters in the text, including spaces.\"\n        data-for=\"charCount\"\n        data-place=\"top\"><strong>Characters:</strong> { analytics.charCount }\n      </div>\n      <ReactTooltip id=\"charCount\" />\n      <div \n        className=\"analysis-item\"\n        data-tip=\"Counts all sentences in the text.\"\n        data-for=\"sentenceCount\"\n        data-place=\"top\"><strong>Sentences:</strong> { analytics.sentenceCount }\n      </div>\n      <ReactTooltip id=\"sentenceCount\" />\n      <div \n        className=\"analysis-item\"\n        data-tip=\"Counts all paragraphs in the text, based on double line breaks.\"\n        data-for=\"paraCount\"\n        data-place=\"top\"><strong>Paragraphs:</strong> { analytics.paragraphCount }\n      </div>\n      <ReactTooltip id=\"paraCount\" />\n      <div \n        className=\"analysis-item\"\n        data-tip=\"Counts all bigrams in the text, based on pairs of non-identical words within the same sentence.<br />Does not count pairs of adjacent words in separate sentences.\"\n        data-for=\"bigramCount\"\n        data-place=\"top\"><strong>Bigrams:</strong> { analytics.bigramCount }\n      </div>\n      <ReactTooltip id=\"bigramCount\" html={true} />\n      <div\n        className=\"analysis-item\"\n        data-tip=\"Uses Wit.ai to perform sentiment analysis on short (280 characters or less) pieces of text <br />that do not contain paragraph breaks.\"\n        data-for=\"sentimentAnalysis\"\n        data-place=\"top\"><strong>Sentiment:</strong> \n        <br />\n        { analytics.sentimentAnalysis }\n      </div>\n      <ReactTooltip id=\"sentimentAnalysis\" />\n    </div>\n  )\n}","import './css/AnalysisContainer.css';\nimport AnalysisForm from './components/AnalysisForm';\nimport AnalysisSidebar from './components/AnalysisSidebar';\n\nexport default function AnalysisContainer({ text, setText, analytics }) {\n  return (\n    <div id=\"analysis-container\">\n      <AnalysisForm\n        text={text}\n        setText={setText}\n      />\n      <AnalysisSidebar\n        analytics={analytics}\n      />\n    </div>\n  )\n}","import './css/App.css';\nimport { useState, useEffect } from 'react';\nimport TextAnalysis from './TextAnalysis';\nimport AnalysisContainer from './AnalysisContainer';\n\nfunction App() {\n  const [text, setText] = useState(''); //sets initial state for text\n  const [analytics, setAnalytics] = useState({\n    charCount: 0,\n    wordCount: 0,\n    sentenceCount: 0,\n    paragraphCount: 0,\n    bigramCount: 0,\n    sentimentAnalysis: 'Unable to determine sentiment at this time.',\n  })\n\n  useEffect(() => { //whenever the text changes, analyze it\n    if (text) { //only if there is text to analyze \n      setAnalytics(prevState => ({\n        ...prevState,\n        charCount: TextAnalysis.getCharCount(text)\n      }));\n      setAnalytics(prevState => ({\n        ...prevState,\n        wordCount: TextAnalysis.getWordCount(text)\n      }));\n      setAnalytics(prevState => ({\n        ...prevState,\n        sentenceCount: TextAnalysis.getSentenceCount(text)\n      }));\n      setAnalytics(prevState => ({\n        ...prevState,\n        paragraphCount: TextAnalysis.getParagraphCount(text)\n      }));\n      setAnalytics(prevState => ({\n        ...prevState,\n        bigramCount: TextAnalysis.getBigramCount(text)\n      }));  \n\n      //SENTIMENT ANALYSIS\n      if (text.length <= 280) { //only call wit.ai API if text within character limits\n        (async () => {\n          const sentiment = await TextAnalysis.sentimentAnalysis(text);\n          setAnalytics(prevState => ({\n            ...prevState,\n            sentimentAnalysis: sentiment,\n          }));\n        })();\n      } else { //if text is too long\n        setAnalytics(prevState => ({\n          ...prevState,\n          sentimentAnalysis: 'Your text is too long for analysis.' \n        }));  \n      }\n    }\n  }, [text]);\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>Wordsworth</h1>\n        <AnalysisContainer \n          text={text} \n          setText={setText}\n          analytics={analytics}\n        />\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './css/index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}